<?php

namespace App\Http\Controllers;

use App\Models\ClientLogin as Buzon;
use App\Models\ClientDomain as Dominio;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash; // ← importar Hash
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;



class BuzonController extends Controller
{
    /**
     * Mostrar listado de buzones (index).
     */
    public function index()
    {
        // La vista se cargará y DataTables pedirá datos por AJAX a datatables()
        return view('vendor.adminlte.pages.buzones.index');
    }

    /**
     * Proveer datos JSON para DataTables (AJAX), filtrando solo los buzones
     * cuyo dominio corresponda al del usuario autenticado.
     */
    public function datatables()
    {
        // 1) Obtener el email completo del usuario actual, ej: "admin@smartcalling.cl"
        $userEmail = auth()->user()->email;

        // 2) Extraer solo la parte del dominio: ej: si email="admin@smartcalling.cl" -> "smartcalling.cl"
        $userDomain = substr(strrchr($userEmail, "@"), 1);

        // 3) Buscar en client_domains el registro cuyo campo `domain` coincida exactamente
        //    con $userDomain (ej: "smartcalling.cl").
        //    Observa que en client_domains.domain se guarda sin "https://" (p. ej.: "smartcalling.cl").
        $dom = Dominio::where('domain', $userDomain)->first();

        if ($dom) {
            // 4) Filtrar client_logins (buzones) por client_domain_id = $dom->id
            $buzonesQuery = Buzon::where('client_domain_id', $dom->id)
                                 ->select(['id', 'login', 'client_domain_id', 'created_at']);
        } else {
            // 5) Si no existe ese dominio, devolvemos un query vacío
            $buzonesQuery = Buzon::whereRaw('0 = 1')
                                 ->select(['id', 'login', 'client_domain_id', 'created_at']);
        }

        return datatables()
            ->of($buzonesQuery)
            ->addColumn('local', function ($b) {
                // Dividir “login” en local/domain. Devuelve la parte antes de "@"
                return strstr($b->login, '@', true);
            })
            ->addColumn('dominio', function ($b) {
                // Devuelve solo la parte después del "@"
                return substr(strrchr($b->login, "@"), 1);
            })
            ->addColumn('creado', function ($b) {
                // Formateo opcional de la fecha de creación
                return $b->created_at->format('Y-m-d H:i:s');
            })
            ->addColumn('acciones', function ($b) {
                $editar = '<a href="'
                          . route('buzones.edit', ['buzone' => $b->id])
                          . '" class="btn btn-sm btn-primary mr-1">
                                 <i class="fas fa-edit"></i>
                             </a>';
                            // Aquí nos aseguramos de incluir el token CSRF y el "metodo" DELETE
                $eliminar = '<form method="POST" action="' . route('buzones.destroy', ['buzone' => $b->id]) . '" style="display:inline;">'
                          .    '<input type="hidden" name="_token" value="' . csrf_token() . '">'
                          .    '<input type="hidden" name="_method" value="DELETE">'
                          .    '<button type="submit" class="btn btn-sm btn-danger" '
                          .            'onclick="return confirm(\'¿Eliminar este buzón?\')">'
                          .        '<i class="fas fa-trash-alt"></i>'
                          .    '</button>'
                          . '</form>';

                return $editar . $eliminar;
            })
            ->rawColumns(['acciones'])
            ->make(true);
    }

    /**
     * Mostrar el formulario para crear un nuevo buzón.
     */
    public function create()
    {
        // 1) Obtener el dominio del usuario autenticado (ej: smartcalling.cl)
        $userEmail  = auth()->user()->email;
        $userDomain = substr(strrchr($userEmail, "@"), 1);

        // 2) Traer solo los client_domains que coincidan con ese $userDomain y estén verificados
        $dominios = Dominio::where('domain', $userDomain)
                           ->where('verified', 1)
                           ->orderBy('domain')
                           ->get();

        return view('vendor.adminlte.pages.buzones.create', compact('dominios'));
    }

    /**
     * Guardar un buzón nuevo.
     */
    public function store(Request $request)
    {
        // Validar solo "local" y "client_domain_id"
        $data = $request->validate([
            'local'            => 'required|string|max:255',
            'client_domain_id' => 'required|exists:client_domains,id',
            'password'         => 'required|string|min:6|confirmed',
        ]);

        // 1) Obtener el dominio real de la lista: 
        $dom = Dominio::findOrFail($data['client_domain_id']);
        $domainPart = $dom->domain; // ej: "smartcalling.cl"

        // 2) Armar el correo completo:
        $login = $data['local'] . '@' . $domainPart;

        // 3) Validar que ese login no exista ya en client_logins
        $request->merge(['login' => $login]); // inyectar "login" en el request para la segunda validación
        $request->validate([
            'login' => 'unique:client_logins,login',
        ]);

        // 4) Crear el registro en client_logins (buzón)
        Buzon::create([
            'client_domain_id' => $data['client_domain_id'],
            'login'            => $login,
            'password'         => Hash::make($data['password']),
       // 'maildir' => null, // lo dejamos null por ahora
        ]);

        return redirect()->route('buzones.index')
                         ->with('success', 'Buzón creado correctamente.');
    }

    /**
     * Mostrar formulario para editar un buzón.
     */
    public function edit(Buzon $buzon)
    {
        // 1) Obtener el dominio del usuario autenticado
        $userEmail  = auth()->user()->email;
        $userDomain = substr(strrchr($userEmail, "@"), 1);

        // 2) Solo traemos el registro de client_domains que coincida con $userDomain
        $dominios = Dominio::where('domain', $userDomain)
                           ->where('verified', 1)
                           ->orderBy('domain')
                           ->get();

        // Pasamos el buzón y los dominios válidos a la vista:
        return view('vendor.adminlte.pages.buzones.edit', compact('buzon', 'dominios'));
    }

    /**
     * Actualizar buzón existente.
     */
    public function update(Request $request, Buzon $buzon)
    {
        // Validar solo "local" y "client_domain_id"
        $data = $request->validate([
            'local'            => 'required|string|max:255',
            'client_domain_id' => 'required|exists:client_domains,id',
            'password'         => 'nullable|string|min:6|confirmed',    
    ]);

        // Obtener el dominio real
        $dom = Dominio::findOrFail($data['client_domain_id']);
        $domainPart = $dom->domain;

        // Armar el nuevo login completo
        $newLogin = $data['local'] . '@' . $domainPart;

        // Validar que ese login no esté en otro buzón distinto al actual
        $request->merge(['login' => $newLogin]);
        $request->validate([
            'login' => 'unique:client_logins,login,' . $buzon->id,
        ]);

        // Preparar array de actualización:
        $updateArray = [
            'client_domain_id' => $data['client_domain_id'],
            'login'            => $newLogin,
        ];

        // Si suministraron password, lo hasheamos; si no, no lo tocamos
        if (!empty($data['password'])) {
            $updateArray['password'] = Hash::make($data['password']);
        }

        // Actualizar campos
        $buzon->update($updateArray);


        return redirect()->route('buzones.index')
                         ->with('success', 'Buzón actualizado correctamente.');
    }

    /**
     * Eliminar un buzón.
     */
    public function destroy(Buzon $buzon)
    {
        // 1) Registrar en log (ya importa el facade Log):
        Log::info("destroy: ejecutando delete() para buzon id={$buzon->id}, login={$buzon->login}");

        // 2) Antes de borrar en client_logins, borrar también en postfixadmin.mailbox
        DB::connection('postfix')
            ->table('mailbox')
            ->where('username', $buzon->login)
            ->delete();

        // 3) Finalmente, borrar el registro en client_logins
        $buzon->delete();

        return redirect()->route('buzones.index')
                         ->with('success', 'Buzón eliminado correctamente.');
    }

}
